====================================================================
REWRITE: SAME 8 QUESTIONS, BUT NOW EACH ONE USES ARGUMENT LOGIC
(so Gradescope can call with argv instead of hardcoded values)
====================================================================

============================================================
Q1) CAT (basic) — already uses argv (kept, minor polish)
Usage: cat1 <file>
============================================================
ANSWER (user/cat1.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if(argc != 2){
    fprintf(2, "usage: cat1 file\n");
    exit(1);
  }

  int fd = open(argv[1], 0);
  if(fd < 0){
    fprintf(2, "cat1: cannot open %s\n", argv[1]);
    exit(1);
  }

  char buf[256];
  int n;
  while((n = read(fd, buf, sizeof(buf))) > 0){
    write(1, buf, n);
  }

  close(fd);
  exit(0);
}

============================================================
Q2) CAT with STDIN + MULTI FILES
Usage:
  catstdin            (reads stdin)
  catstdin f1 f2 ...  (cats each file in order)
============================================================
ANSWER (user/catstdin.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

static void
copy(int fd)
{
  char buf[256];
  int n;
  while((n = read(fd, buf, sizeof(buf))) > 0){
    write(1, buf, n);
  }
}

int
main(int argc, char *argv[])
{
  if(argc == 1){
    copy(0);
    exit(0);
  }

  for(int i = 1; i < argc; i++){
    int fd = open(argv[i], 0);
    if(fd < 0){
      fprintf(2, "catstdin: cannot open %s\n", argv[i]);
      continue;
    }
    copy(fd);
    close(fd);
  }

  exit(0);
}

============================================================
Q3) SIMPLE I/O REDIRECTION (stdout) — output file comes from argv
Usage: redirect <outfile> <prog> [args...]
Example: redirect out.txt ls -l
============================================================
ANSWER (user/redirect.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/fcntl.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if(argc < 3){
    fprintf(2, "usage: redirect outfile prog [args...]\n");
    exit(1);
  }

  int fd = open(argv[1], O_CREATE | O_WRONLY | O_TRUNC);
  if(fd < 0){
    fprintf(2, "redirect: cannot open %s\n", argv[1]);
    exit(1);
  }

  close(1);
  dup(fd);
  close(fd);

  // exec argv[2] with arguments starting at argv[2]
  exec(argv[2], &argv[2]);

  fprintf(2, "redirect: exec failed\n");
  exit(1);
}

============================================================
Q4) SIMPLE PIPE (one direction) — message comes from argv
Usage: pipe1 <message>
Example: pipe1 hello
Child prints: "<childpid>: hello"
============================================================
ANSWER (user/pipe1.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if(argc != 2){
    fprintf(2, "usage: pipe1 message\n");
    exit(1);
  }

  int p[2];
  pipe(p);

  int pid = fork();
  if(pid == 0){
    close(p[1]);

    char buf[64];
    int n = read(p[0], buf, sizeof(buf));
    if(n > 0){
      printf("%d: ", getpid());
      write(1, buf, n);
      if(buf[n-1] != '\n') write(1, "\n", 1);
    }

    close(p[0]);
    exit(0);
  } else {
    close(p[0]);

    // send argv[1] bytes (no null terminator needed)
    write(p[1], argv[1], strlen(argv[1]));
    close(p[1]);

    wait(0);
    exit(0);
  }
}

============================================================
Q5) GREP (simple substring) — support MULTI files via argv
Usage:
  grep1 <pattern> <file1> [file2...]
============================================================
ANSWER (user/grep1.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

static int
contains(char *s, char *p)
{
  for(int i = 0; s[i]; i++){
    int j = 0;
    while(p[j] && s[i+j] == p[j]) j++;
    if(p[j] == 0) return 1;
  }
  return 0;
}

static void
grep_fd(int fd, char *pattern)
{
  char buf[512];
  int keep = 0, n;

  while((n = read(fd, buf+keep, sizeof(buf)-keep-1)) > 0){
    int total = keep + n;
    buf[total] = 0;

    int start = 0;
    for(int i = 0; i < total; i++){
      if(buf[i] == '\n'){
        buf[i] = 0;
        if(contains(buf+start, pattern))
          printf("%s\n", buf+start);
        start = i+1;
      }
    }

    keep = total - start;
    memmove(buf, buf+start, keep);
  }
}

int
main(int argc, char *argv[])
{
  if(argc < 3){
    fprintf(2, "usage: grep1 pattern file...\n");
    exit(1);
  }

  char *pattern = argv[1];

  for(int i = 2; i < argc; i++){
    int fd = open(argv[i], 0);
    if(fd < 0){
      fprintf(2, "grep1: cannot open %s\n", argv[i]);
      continue;
    }
    grep_fd(fd, pattern);
    close(fd);
  }

  exit(0);
}

============================================================
Q6) NUMBERS FILTER (even) — take numbers from argv (multi nums)
Usage: evenM n1 n2 n3 ...
Print only even numbers
============================================================
ANSWER (user/evenM.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if(argc < 2){
    fprintf(2, "usage: evenM nums...\n");
    exit(1);
  }

  for(int i = 1; i < argc; i++){
    int n = atoi(argv[i]);
    if(n % 2 == 0)
      printf("%d\n", n);
  }

  exit(0);
}

============================================================
Q7) PRIMES (sieve) — range comes from argv
Usage: primes1 <start> <end>
Example: primes1 2 35
============================================================
ANSWER (user/primes1.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

static void
primes(int fd)
{
  int p;
  if(read(fd, &p, sizeof(int)) == 0)
    exit(0);

  printf("prime %d\n", p);

  int n;
  int p2[2];
  pipe(p2);

  if(fork() == 0){
    close(p2[1]);
    primes(p2[0]);
  } else {
    close(p2[0]);
    while(read(fd, &n, sizeof(int)) > 0){
      if(n % p != 0)
        write(p2[1], &n, sizeof(int));
    }
    close(p2[1]);
    wait(0);
    exit(0);
  }
}

int
main(int argc, char *argv[])
{
  if(argc != 3){
    fprintf(2, "usage: primes1 start end\n");
    exit(1);
  }

  int start = atoi(argv[1]);
  int end   = atoi(argv[2]);

  int p[2];
  pipe(p);

  if(fork() == 0){
    close(p[1]);
    primes(p[0]);
  } else {
    close(p[0]);
    for(int i = start; i <= end; i++)
      write(p[1], &i, sizeof(int));
    close(p[1]);
    wait(0);
  }

  exit(0);
}

============================================================
Q8) FORK ONLY — count comes from argv
Usage: fork1 N
Fork N children. Each child prints its pid.
Parent prints its pid and each child pid returned by fork().
============================================================
ANSWER (user/fork1.c):
------------------------------------------------------------
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if(argc != 2){
    fprintf(2, "usage: fork1 N\n");
    exit(1);
  }

  int N = atoi(argv[1]);

  printf("parent pid=%d\n", getpid());

  for(int i = 0; i < N; i++){
    int pid = fork();
    if(pid == 0){
      printf("child pid=%d\n", getpid());
      exit(0);
    } else if(pid > 0){
      printf("fork returned child=%d\n", pid);
    } else {
      fprintf(2, "fork failed\n");
      break;
    }
  }

  // reap children
  for(int i = 0; i < N; i++)
    wait(0);

  exit(0);
}

====================================================================
END (ALL NOW USE argv INPUT IN A GRADESCOPE-FRIENDLY WAY)
====================================================================
