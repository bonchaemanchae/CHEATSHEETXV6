# NOVEL Q3 EXAM QUESTIONS - Complete Working Solutions
## 5 Realistic "New But Related" Questions

**Pattern:** NOT direct Lab 3/5 twists, but NEW small tasks testing same core skills.

**Coverage:**
1. ‚úÖ Syscall pipeline mastery
2. ‚úÖ Register save/restore understanding
3. ‚úÖ Race condition awareness
4. ‚úÖ Process state management
5. ‚úÖ Kernel/user boundary

---

# 1Ô∏è‚É£ NEW SYSCALL: getppid() or getnproc()

## Question Stem A: Get Parent Process ID

```
Implement getppid() system call:
- Returns parent process ID
- Use 9-file syscall pattern
- Test: fork() ‚Üí child calls getppid() ‚Üí prints parent PID

Example output:
$ getppid_test
Parent PID: 100
Child PID: 101
Child's parent PID: 100
```

---

## ‚úÖ COMPLETE SOLUTION - getppid()

### File 1: kernel/syscall.h
```c
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_getppid 22  // NEW: Add getppid
```

---

### File 2: kernel/sysproc.c
```c
// Existing code...

uint64
sys_getpid(void)
{
  return myproc()->pid;
}

// NEW: Add getppid implementation
uint64
sys_getppid(void)
{
  struct proc *p = myproc();
  
  // Parent pointer stored in proc struct
  // Return parent's PID (or 1 if no parent)
  if (p->parent) {
    return p->parent->pid;
  }
  return 1;  // init process has no parent, return 1
}

uint64
sys_sbrk(void)
{
  uint64 addr;
  int n;

  argint(0, &n);
  addr = myproc()->sz;
  if(growproc(n) < 0)
    return -1;
  return addr;
}
```

---

### File 3: user/user.h
```c
// System calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(const char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
int getppid(void);  // NEW: Add declaration
int sbrk(int);
int sleep(int);
int uptime(void);
```

---

### File 4: user/usys.pl
```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("getppid");  # NEW: Add stub generation
entry("sbrk");
entry("sleep");
entry("uptime");
```

---

### File 5: kernel/syscall.c
```c
// ... existing code ...

extern uint64 sys_chdir(void);
extern uint64 sys_close(void);
extern uint64 sys_dup(void);
extern uint64 sys_exec(void);
extern uint64 sys_exit(void);
extern uint64 sys_fork(void);
extern uint64 sys_fstat(void);
extern uint64 sys_getpid(void);
extern uint64 sys_getppid(void);  // NEW: Add extern declaration
extern uint64 sys_kill(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_mknod(void);
extern uint64 sys_open(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_unlink(void);
extern uint64 sys_uptime(void);
extern uint64 sys_wait(void);
extern uint64 sys_write(void);

// Array of syscall function pointers
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_getppid] sys_getppid,  // NEW: Add to array
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
};

// Syscall names (for debugging/monitor)
static char *syscall_names[] = {
[SYS_fork]    "fork",
[SYS_exit]    "exit",
[SYS_wait]    "wait",
[SYS_pipe]    "pipe",
[SYS_read]    "read",
[SYS_kill]    "kill",
[SYS_exec]    "exec",
[SYS_fstat]   "fstat",
[SYS_chdir]   "chdir",
[SYS_dup]     "dup",
[SYS_getpid]  "getpid",
[SYS_getppid] "getppid",  // NEW: Add to names array
[SYS_sbrk]    "sbrk",
[SYS_sleep]   "sleep",
[SYS_uptime]  "uptime",
[SYS_open]    "open",
[SYS_write]   "write",
[SYS_mknod]   "mknod",
[SYS_unlink]  "unlink",
[SYS_link]    "link",
[SYS_mkdir]   "mkdir",
[SYS_close]   "close",
};

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

---

### File 6: kernel/proc.h
```c
// NO CHANGES NEEDED
// proc struct already has 'struct proc *parent;' field
```

---

### File 7: kernel/proc.c
```c
// NO CHANGES NEEDED
// allocproc() already sets p->parent
// fork() already sets np->parent = p
```

---

### File 8: user/getppid_test.c (NEW TEST PROGRAM)
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    int parent_pid = getpid();
    
    printf("Parent PID: %d\n", parent_pid);
    
    int pid = fork();
    
    if (pid < 0) {
        fprintf(2, "fork failed\n");
        exit(1);
    }
    
    if (pid == 0) {
        // CHILD PROCESS
        int my_pid = getpid();
        int my_parent_pid = getppid();
        
        printf("Child PID: %d\n", my_pid);
        printf("Child's parent PID: %d\n", my_parent_pid);
        
        // Verify
        if (my_parent_pid == parent_pid) {
            printf("‚úì getppid() correct!\n");
        } else {
            printf("‚úó ERROR: expected %d, got %d\n", parent_pid, my_parent_pid);
        }
        
        exit(0);
    } else {
        // PARENT
        wait(0);
    }
    
    exit(0);
}
```

---

### File 9: Makefile
```makefile
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_getppid_test\  # NEW: Add test program

# ... rest of Makefile unchanged ...
```

---

### Expected Output:
```bash
$ make qemu
...
$ getppid_test
Parent PID: 3
Child PID: 4
Child's parent PID: 3
‚úì getppid() correct!
```

---

## Question Stem B: Get Number of Processes

```
Implement getnproc() system call:
- Returns count of active processes (state != UNUSED)
- Use same 9-file pattern
- Test: print number of running processes

Example output:
$ getnproc_test
Active processes: 3
```

---

## ‚úÖ COMPLETE SOLUTION - getnproc()

### Key Implementation (kernel/sysproc.c):
```c
uint64
sys_getnproc(void)
{
  struct proc *p;
  int count = 0;
  
  // Iterate through process table
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state != UNUSED) {
      count++;
    }
    release(&p->lock);
  }
  
  return count;
}
```

### Test Program (user/getnproc_test.c):
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    printf("Active processes: %d\n", getnproc());
    
    // Create 3 children
    for (int i = 0; i < 3; i++) {
        if (fork() == 0) {
            // Child sleeps
            sleep(10);
            exit(0);
        }
    }
    
    printf("After forking 3 children: %d\n", getnproc());
    
    // Wait for children
    for (int i = 0; i < 3; i++) {
        wait(0);
    }
    
    printf("After children exit: %d\n", getnproc());
    
    exit(0);
}
```

**Same 9-file pattern as getppid() - just change function name and implementation.**

---

# 2Ô∏è‚É£ SLEEP FOR N TICKS (WITH TRACKING)

## Question Stem:

```
Implement mysleep(int ticks) that:
- Sleeps for N ticks
- Returns actual ticks slept
- Prints wakeup message

Example:
$ mysleep_test 100
Sleeping for 100 ticks...
Woke up after 100 ticks
```

---

## ‚úÖ COMPLETE SOLUTION

### File 1: kernel/syscall.h
```c
#define SYS_mysleep 23  // NEW
```

---

### File 2: kernel/sysproc.c
```c
uint64
sys_mysleep(void)
{
  int n;
  uint ticks0;

  argint(0, &n);
  
  if(n < 0)
    n = 0;
  
  acquire(&tickslock);
  ticks0 = ticks;  // Record start time
  
  while(ticks - ticks0 < n){
    if(killed(myproc())){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  
  uint ticks_slept = ticks - ticks0;  // Calculate actual duration
  release(&tickslock);
  
  // Print wakeup message from kernel
  printf("%d: woke up after %d ticks\n", myproc()->pid, ticks_slept);
  
  return ticks_slept;
}
```

---

### File 3: user/user.h
```c
int mysleep(int);  // NEW
```

---

### File 4: user/usys.pl
```perl
entry("mysleep");  # NEW
```

---

### File 5: kernel/syscall.c
```c
extern uint64 sys_mysleep(void);  // NEW

static uint64 (*syscalls[])(void) = {
  // ... existing entries ...
  [SYS_mysleep] sys_mysleep,  // NEW
};

static char *syscall_names[] = {
  // ... existing entries ...
  [SYS_mysleep] = "mysleep",  // NEW
};
```

---

### File 6-7: No changes needed (no new proc fields)

---

### File 8: user/mysleep_test.c (NEW)
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    int ticks = 100;
    
    if (argc == 2) {
        ticks = atoi(argv[1]);
    }
    
    printf("Sleeping for %d ticks...\n", ticks);
    
    int actual = mysleep(ticks);
    
    printf("Returned: %d ticks\n", actual);
    
    exit(0);
}
```

---

### File 9: Makefile
```makefile
UPROGS=\
	# ... existing programs ...
	$U/_mysleep_test\  # NEW
```

---

### Expected Output:
```bash
$ mysleep_test 100
Sleeping for 100 ticks...
100: woke up after 100 ticks
Returned: 100 ticks
```

---

# 3Ô∏è‚É£ MONITOR WITH FORK DEPTH

## Question Stem:

```
Modify monitor syscall to include fork depth:
- Depth 0: Parent process
- Depth 1: Child of parent
- Depth 2: Grandchild
- Print: "pid (depth N): syscall read -> 5"

Example:
$ monitor_depth 31 sh
3 (depth 0): syscall read -> 1
4 (depth 1): syscall write -> 10
5 (depth 2): syscall open -> 3
```

---

## ‚úÖ COMPLETE SOLUTION

### File 1: kernel/proc.h
```c
struct proc {
  struct spinlock lock;

  // ... existing fields ...
  
  uint32 monitor_mask;  // existing from Lab 3
  int fork_depth;       // NEW: Track depth from original process
};
```

---

### File 2: kernel/proc.c

**In allocproc():**
```c
static struct proc*
allocproc(void)
{
  // ... existing allocation code ...
  
found:
  p->pid = allocpid();
  p->state = USED;
  p->monitor_mask = 0;
  p->fork_depth = 0;  // NEW: Initialize to 0

  // ... rest of function ...
  return p;
}
```

**In fork():**
```c
int
fork(void)
{
  // ... existing fork code ...
  
  // Copy monitor settings
  np->monitor_mask = p->monitor_mask;
  np->fork_depth = p->fork_depth + 1;  // NEW: Increment depth
  
  // ... rest of fork ...
  return pid;
}
```

---

### File 3: kernel/sysproc.c
```c
uint64
sys_monitor(void)
{
  int mask;
  argint(0, &mask);
  
  struct proc *p = myproc();
  p->monitor_mask = mask;
  p->fork_depth = 0;  // NEW: Reset depth when monitor() called
  
  return 0;
}
```

---

### File 4: kernel/syscall.c
```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
    
    // Check if monitoring this syscall
    if ((p->monitor_mask & (1 << num)) && syscall_names[num]) {
      // NEW: Include fork depth in output
      printf("%d (depth %d): syscall %s -> %ld\n",
             p->pid,
             p->fork_depth,  // NEW
             syscall_names[num],
             p->trapframe->a0);
    }
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

---

### File 5: user/monitor_depth_test.c (NEW)
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    // Enable monitoring for read/write
    monitor((1 << 5) | (1 << 16));  // SYS_read=5, SYS_write=16
    
    printf("Parent (depth 0):\n");
    write(1, "x", 1);
    
    if (fork() == 0) {
        // Child - depth 1
        printf("\nChild (depth 1):\n");
        write(1, "y", 1);
        
        if (fork() == 0) {
            // Grandchild - depth 2
            printf("\nGrandchild (depth 2):\n");
            write(1, "z", 1);
            exit(0);
        }
        
        wait(0);
        exit(0);
    }
    
    wait(0);
    exit(0);
}
```

---

### File 6: Makefile
```makefile
UPROGS=\
	# ... existing programs ...
	$U/_monitor_depth_test\  # NEW
```

---

### Expected Output:
```bash
$ monitor_depth_test
Parent (depth 0):
3 (depth 0): syscall write -> 1
x
Child (depth 1):
4 (depth 1): syscall write -> 1
y
Grandchild (depth 2):
5 (depth 2): syscall write -> 1
z
```

---

# 4Ô∏è‚É£ THREAD-SAFE COUNTER (MINIMAL MUTEX)

## Question Stem:

```
Fix thread-unsafe counter:

Given:
- Shared counter = 0
- 2 threads each increment 100000 times
- Output: counter = 137482 (WRONG!)

Fix using pthread_mutex_t:
- Add lock
- Protect critical section
- Output: counter = 200000 (CORRECT!)
```

---

## ‚úÖ COMPLETE SOLUTION

### File: notxv6/counter_broken.c (GIVEN)
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NITER 100000

int counter = 0;  // Shared variable

void *increment(void *arg) {
    for (int i = 0; i < NITER; i++) {
        counter++;  // RACE CONDITION!
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t t1, t2;
    
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("Counter: %d (expected 200000)\n", counter);
    return 0;
}
```

**Output:**
```
Counter: 137482 (expected 200000)  ‚Üê WRONG due to race!
```

---

### File: notxv6/counter_fixed.c (SOLUTION)
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NITER 100000

int counter = 0;
pthread_mutex_t counter_lock;  // NEW: Add mutex

void *increment(void *arg) {
    for (int i = 0; i < NITER; i++) {
        pthread_mutex_lock(&counter_lock);   // NEW: Lock before
        counter++;
        pthread_mutex_unlock(&counter_lock); // NEW: Unlock after
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t t1, t2;
    
    pthread_mutex_init(&counter_lock, NULL);  // NEW: Initialize
    
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("Counter: %d (expected 200000)\n", counter);
    
    pthread_mutex_destroy(&counter_lock);  // NEW: Cleanup
    
    return 0;
}
```

**Output:**
```
Counter: 200000 (expected 200000)  ‚Üê CORRECT!
```

---

### What Changed:
1. **Added `pthread_mutex_t counter_lock`** - Global mutex
2. **pthread_mutex_init()** - Initialize before threads
3. **pthread_mutex_lock()** - BEFORE counter++
4. **pthread_mutex_unlock()** - AFTER counter++
5. **pthread_mutex_destroy()** - Cleanup at end

---

### Why It Was Broken:

**Assembly of `counter++` is 3 instructions:**
```asm
lw   a0, counter    # Load value
addi a0, a0, 1      # Add 1
sw   a0, counter    # Store back
```

**Race condition timeline:**
```
Thread 1          Thread 2          Counter
lw (100)                            100
                  lw (100)          100
addi (101)                          100
                  addi (101)        100
sw (101)                            101  ‚Üê Should be 102!
                  sw (101)          101  ‚Üê Lost update!
```

**With mutex:**
- Thread 1 locks ‚Üí counter++ ‚Üí unlocks
- Thread 2 waits ‚Üí then locks ‚Üí counter++ ‚Üí unlocks
- No interleaving = no lost updates

---

### Compile and Run:
```bash
# Broken version
$ gcc -pthread counter_broken.c -o counter_broken
$ ./counter_broken
Counter: 143891 (expected 200000)  ‚Üê random wrong value

# Fixed version
$ gcc -pthread counter_fixed.c -o counter_fixed
$ ./counter_fixed
Counter: 200000 (expected 200000)  ‚Üê always correct!
```

---

# 5Ô∏è‚É£ BROKEN UTHREAD - FIND MISSING REGISTER

## Question Stem:

```
This uthread_switch.S is BROKEN:

    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    sd s1, 24(a0)
    sd s2, 32(a0)
    # MISSING: sd s3, 40(a0)  ‚Üê BUG!
    sd s4, 48(a0)
    sd s5, 56(a0)
    # ... rest ...

Questions:
1. Why does this cause thread corruption?
2. Which 2 lines must you add to fix it?
3. What are the 14 registers that MUST be saved?
```

---

## ‚úÖ COMPLETE SOLUTION

### Answer 1: Why It Breaks

**Scenario:**
```
Thread A runs:
- Uses s3 register to store local variable X
- Context switch happens
- s3 NOT saved ‚Üê BUG!

Thread B runs:
- Uses s3 for its own variable Y
- Overwrites s3 (X is lost)

Thread A resumes:
- Reads s3, expecting X
- Gets Y instead ‚Üê CORRUPTION!
- Program crashes or produces wrong results
```

**Why s3?**
- **Callee-saved register** (RISC-V ABI)
- Compiler assumes thread_switch() saves it
- If not saved, compiler's assumption violated
- Unpredictable behavior

---

### Answer 2: Missing Lines

**user/uthread_switch.S (FIXED):**
```asm
.globl thread_switch
thread_switch:
    # Save context of current thread (a0 points to context)
    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    sd s1, 24(a0)
    sd s2, 32(a0)
    sd s3, 40(a0)     # FIX: Add this line
    sd s4, 48(a0)
    sd s5, 56(a0)
    sd s6, 64(a0)
    sd s7, 72(a0)
    sd s8, 80(a0)
    sd s9, 88(a0)
    sd s10, 96(a0)
    sd s11, 104(a0)
    
    # Restore context of next thread (a1 points to context)
    ld ra, 0(a1)
    ld sp, 8(a1)
    ld s0, 16(a1)
    ld s1, 24(a1)
    ld s2, 32(a1)
    ld s3, 40(a1)     # FIX: Add this line
    ld s4, 48(a1)
    ld s5, 56(a1)
    ld s6, 64(a1)
    ld s7, 72(a1)
    ld s8, 80(a1)
    ld s9, 88(a1)
    ld s10, 96(a1)
    ld s11, 104(a1)
    
    ret
```

**Two lines added:**
1. `sd s3, 40(a0)` - Save s3 from old thread
2. `ld s3, 40(a1)` - Restore s3 to new thread

---

### Answer 3: The 14 Required Registers

**From RISC-V Calling Convention:**

| Register | Purpose | Why Save? |
|----------|---------|-----------|
| **ra** | Return address | Where to return after thread_switch |
| **sp** | Stack pointer | Each thread has own stack |
| **s0-s11** | Saved registers | Callee must preserve (12 registers) |

**Total: 14 registers**

**NOT saved:**
- **a0-a7** (arguments) - Caller-saved
- **t0-t6** (temporaries) - Caller-saved
- **gp, tp** (global/thread pointers) - Special purpose

---

### Verification Test

**user/uthread_verify.c:**
```c
#include "kernel/types.h"
#include "user/user.h"
#include "user/uthread.h"

volatile int test_var = 0;

void thread_a(void) {
    // Use s3 heavily (compiler will allocate)
    int local_a = 100;
    
    for (int i = 0; i < 100; i++) {
        local_a += i;  // Likely uses s3
        thread_yield();
        
        // Verify local_a not corrupted
        if (local_a < 100) {
            printf("ERROR: thread_a corrupted! local_a=%d\n", local_a);
            exit(1);
        }
    }
    
    printf("thread_a: completed successfully (local_a=%d)\n", local_a);
    test_var = 1;
    thread_exit();
}

void thread_b(void) {
    int local_b = 200;
    
    for (int i = 0; i < 100; i++) {
        local_b += i * 2;  // Different computation
        thread_yield();
        
        if (local_b < 200) {
            printf("ERROR: thread_b corrupted! local_b=%d\n", local_b);
            exit(1);
        }
    }
    
    printf("thread_b: completed successfully (local_b=%d)\n", local_b);
    test_var = 2;
    thread_exit();
}

int main(int argc, char *argv[]) {
    thread_init();
    
    printf("Testing thread context save/restore...\n");
    
    thread_create(thread_a);
    thread_create(thread_b);
    
    thread_schedule();
    
    exit(0);
}
```

**With bug (missing s3):**
```
Testing thread context save/restore...
ERROR: thread_a corrupted! local_a=-42
```

**With fix (s3 saved):**
```
Testing thread context save/restore...
thread_a: completed successfully (local_a=5050)
thread_b: completed successfully (local_b=10100)
```

---

### Debug Tip: How to Find Missing Register

**If exam gives broken switch code:**

1. **Count the sd/ld pairs:**
   - Should be 14 pairs (ra, sp, s0-s11)
   - If you count 13 pairs ‚Üí 1 missing

2. **Check offsets:**
   - Each register = 8 bytes
   - Offsets should be: 0, 8, 16, 24, 32, 40, 48, ...
   - If offset jumps from 32 to 48 ‚Üí missing 40 (s3)

3. **Check register sequence:**
   - RISC-V order: ra, sp, s0, s1, s2, s3, s4, ...
   - Missing s3 is most common exam trick

---

### Context Struct Must Match

**user/uthread.c:**
```c
struct thread_context {
    uint64 ra;
    uint64 sp;
    uint64 s0;
    uint64 s1;
    uint64 s2;
    uint64 s3;   // Must be here
    uint64 s4;
    uint64 s5;
    uint64 s6;
    uint64 s7;
    uint64 s8;
    uint64 s9;
    uint64 s10;
    uint64 s11;
};
```

**If s3 missing from struct:**
- Assembly offsets will be wrong
- Must add `uint64 s3;` to struct

---

# üéØ SUMMARY: 5 NOVEL Q3 QUESTIONS

| # | Question | Core Skill Tested | Difficulty |
|---|----------|-------------------|------------|
| 1 | **getppid() / getnproc()** | Syscall 9-file pipeline | Easy |
| 2 | **mysleep() with tracking** | Process state + return values | Easy |
| 3 | **Monitor with fork depth** | Process hierarchy + tracing | Medium |
| 4 | **Thread-safe counter** | Race conditions + mutex | Easy |
| 5 | **Broken uthread (missing s3)** | Register save/restore | Medium |

---

# üìã QUICK CHEAT SHEET

## 9-File Syscall Pattern:
1. **syscall.h** - `#define SYS_xxx 22`
2. **sysproc.c** - `uint64 sys_xxx(void) { ... }`
3. **user.h** - `int xxx(void);`
4. **usys.pl** - `entry("xxx");`
5. **syscall.c** - extern, array, names
6. **proc.h** - add field if needed
7. **proc.c** - init/copy field if needed
8. **user/*.c** - test program
9. **Makefile** - add to UPROGS

## Mutex Pattern:
```c
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);
pthread_mutex_lock(&lock);
// critical section
pthread_mutex_unlock(&lock);
pthread_mutex_destroy(&lock);
```

## Register Save Pattern:
```asm
# RISC-V: Save ra, sp, s0-s11 (14 registers)
sd ra, 0(a0)
sd sp, 8(a0)
sd s0, 16(a0)
# ... s1 through s11 ...
```

---

# üéì EXAM STRATEGY

**If Q3 appears:**

1. **Read carefully** - Identify which skill they're testing
2. **Match to pattern** - Is it syscall? threads? race condition?
3. **Use template** - 9-file for syscall, mutex for race, etc.
4. **Don't overthink** - They won't ask for new kernel subsystems
5. **Test your code** - Write test program to verify

**Time allocation:**
- Syscall questions: 20-25 minutes (mechanical)
- Thread/mutex questions: 15-20 minutes (smaller scope)
- Debug questions: 10-15 minutes (find the bug)

**Common mistakes:**
- ‚ùå Forgetting to add syscall to **all 9 files**
- ‚ùå Not holding lock when accessing shared data
- ‚ùå Missing registers in thread_switch
- ‚ùå Not testing with fork() for process-related syscalls

**Safety checks before submitting:**
- ‚úÖ Syscall added to syscalls[] array?
- ‚úÖ Syscall added to syscall_names[] array?
- ‚úÖ Lock held during critical section?
- ‚úÖ All 14 registers saved in thread_switch?
- ‚úÖ Test program demonstrates correctness?

---

**END OF NOVEL Q3 SOLUTIONS**
