#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  int p2c[2];   // parent -> child
  int c2p[2];   // child  -> parent
  char x;

  if (pipe(p2c) < 0 || pipe(c2p) < 0) {
    fprintf(2, "pipe failed\n");
    exit(1);
  }

  int pid = fork();
  if (pid < 0) {
    fprintf(2, "fork failed\n");
    exit(1);
  }

  if (pid == 0) {
    // ===== CHILD =====
    close(p2c[1]);  // child doesn't write to p2c
    close(c2p[0]);  // child doesn't read from c2p

    if (read(p2c[0], &x, 1) != 1) {
      fprintf(2, "child read failed\n");
      exit(1);
    }

    printf("%d: received %c from parent\n", getpid(), x);

    if (write(c2p[1], &x, 1) != 1) {
      fprintf(2, "child write failed\n");
      exit(1);
    }

    close(p2c[0]);
    close(c2p[1]);
    exit(0);

  } else {
    // ===== PARENT =====
    close(p2c[0]);  // parent doesn't read from p2c
    close(c2p[1]);  // parent doesn't write to c2p

    x = 'A';
    if (write(p2c[1], &x, 1) != 1) {
      fprintf(2, "parent write failed\n");
      exit(1);
    }

    if (read(c2p[0], &x, 1) != 1) {
      fprintf(2, "parent read failed\n");
      exit(1);
    }

    printf("%d: received %c from child\n", getpid(), x);

    close(p2c[1]);
    close(c2p[0]);
    wait(0);
    exit(0);
  }
}


ANNA SOLN
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char* argv[]){
    int pid;
    int pfd[2];
    int cfd[2];
    char byte = atoi(argv[1]);
    char buffer[1];

    pipe(pfd);
    pipe(cfd);
    
    // if(pipe(fd) == -1){
    //     printf("pipe error\n");
    // }

    pid = fork();

    if(pid==0){
        // close(pfd[1]); 
        // close(cfd[0]);
        read(pfd[0], buffer, 1);
        printf("%d: received %d from parent\n", getpid(), buffer[0]);
        write(cfd[1], buffer, 1);
        close(pfd[0]); //close read from parent
        close(cfd[1]); //close write from child

    } else {
        // close(cfd[1]); //close read from child
        // close(pfd[0]); //close write from parent
        write(pfd[1], &byte, 1);   
        read(cfd[0], buffer, 1);
        printf("%d: received %d from child\n", getpid(), buffer[0]);
        close(cfd[0]); 
        close(pfd[1]); 
    }
    exit(0);
}

-----------------------------------------------------------------
SIMPLE VERSION
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  int p2c[2];   // parent -> child
  int c2p[2];   // child  -> parent
  char x;
  char buf[1];

  if (pipe(p2c) < 0 || pipe(c2p) < 0) {
    fprintf(2, "pipe failed\n");
    exit(1);
  }

  int pid = fork();
  if (pid < 0) {
    fprintf(2, "fork failed\n");
    exit(1);
  }

  if (pid == 0) {
    // ===== CHILD =====
    close(p2c[1]);  // child doesn't write to p2c
    close(c2p[0]);  // child doesn't read from c2p

    read(p2c[0], buf, 1);
    printf("%d: received %c from parent\n", getpid(), buf[0]);

    write(c2p[1], buf, 1);

    close(p2c[0]);
    close(c2p[1]);
    exit(0);
  } else {
    // ===== PARENT =====
    close(p2c[0]);  // parent doesn't read from p2c
    close(c2p[1]);  // parent doesn't write to c2p

    x = 'A';
    write(p2c[1], &x, 1);

    read(c2p[0], buf, 1);
    printf("%d: received %c from child\n", getpid(), buf[0]);

    close(p2c[1]);
    close(c2p[0]);
    wait(0);
    exit(0);
  }
}

