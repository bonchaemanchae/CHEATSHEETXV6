The universal mental model
The 3 channels every utility lives on

fd 0 = stdin (where it reads from)

fd 1 = stdout (where it writes normal output)

fd 2 = stderr (where it writes errors)

Every utility is basically:

read bytes from some fd

process (optional)

write bytes to fd 1 (or fd 2 for errors)

If you remember only one thing: utilities don’t “know” if input is keyboard / file / pipe. They just read fd 0 or a file descriptor.

1) File read pattern (cat-style)
Goal

Print a file to stdout.

Flow

Parse args: ensure you have the filename (or decide stdin if none).

open(filename, O_RDONLY) (or use fd 0 if stdin mode).

Loop:

read(fd, buf, N)

if n > 0: write(1, buf, n)

if n == 0: EOF → stop

if n < 0: error → print to fd 2

close(fd) if it was an opened file.

Traps checklist

If “stdin mode”: you do not open anything; use fd 0.

Don’t assume reads align to lines; reads are just bytes.

2) Line-based processing pattern (grep-style)
Goal

Filter and print only lines that match a pattern.

Flow

Parse args: pattern + optional filename.

Choose input fd:

if file provided: open(file)

else: use fd 0 (stdin)

Maintain a line buffer (because reads are chunks, but you need lines).

Loop:

read(fd, chunk)

append into buffer

while buffer contains \n:

extract one line

test match

if match: print line to stdout

keep leftover partial line for next read

At EOF:

if leftover exists (no trailing newline): process it too

Close file fd if opened.

Traps checklist

Pattern matching is usually substring (simple) unless told otherwise.

Must handle line split across multiple reads.

3) Simple fork pattern (run one command)
Goal

Create a child to do work; parent waits.

Flow

pid = fork()

If pid == 0 (child):

do child work (or exec)

exit()

Else (parent):

wait(0)

continue / exit

Traps checklist

Always handle pid < 0 (fork failure) if exam expects robustness.

Child must exit() so it doesn’t “fall through” into parent logic.

4) One-direction pipe pattern (parent → child)
Goal

Send data one way through a pipe.

Flow

pipe(p) → now have p[0]=read, p[1]=write

fork()

Child side:

close write end close(p[1])

read(p[0], ...) (blocks until parent writes or EOF)

process/print

close(p[0])

exit()

Parent side:

close read end close(p[0])

write(p[1], ...)

close write end close(p[1]) (important for EOF)

wait(0)

Traps checklist

If parent doesn’t close p[1], child may block waiting for EOF.

If child doesn’t close p[1], EOF may never happen either (because child still has a write end open).

5) Two-way handshake pattern (ping-pong with two pipes)
Goal

Send a message and get a reply.

Setup

p2c for parent→child

c2p for child→parent

Flow

pipe(p2c); pipe(c2p); fork()

Child side:

Close unused ends:

close p2c[1] (child won’t write there)

close c2p[0] (child won’t read there)

read(p2c[0])

print “received ping”

write(c2p[1])

close used ends; exit()

Parent side:

Close unused ends:

close p2c[0]

close c2p[1]

write(p2c[1])

read(c2p[0])

print “received pong”

close used ends; wait(0)

Traps checklist

Ordering: one side must write first, other reads first OR it deadlocks.

Missing closes = reads block forever.

6) Exec pattern (child becomes another program)
Goal

Fork a child, then run another program in child.

Flow

fork()

Child:

exec("prog", args)

if exec fails: print error, exit(1)

Parent:

wait(0)

Traps checklist

After exec, the child program starts fresh; old code/variables gone.

args[0] should be program name conventionally.

7) I/O redirection pattern (< and >)

This is shell behaviour, but if asked to implement redirection in a program, the steps are the same.

Output redirection (>): make stdout go to file
Flow

open("out.txt", create|write|truncate)

close(1) (free fd 1)

dup(filefd) → duplicates to lowest free fd, which is now 1

close(filefd) (cleanup)

exec(program, args) (or continue writing to stdout)

Input redirection (<): make stdin come from file
Flow

open("in.txt", read)

close(0)

dup(filefd) → becomes fd 0

close(filefd)

exec(program, args) (program reads stdin normally)

Traps checklist

Must close(0) or close(1) first, otherwise dup won’t land on the correct fd.

Redirection must happen before exec if you want the new program to inherit it.

8) Pipeline pattern (A | B)
Goal

Connect stdout of A to stdin of B.

Flow (what the shell does)

pipe(p)

Fork child A:

redirect stdout:

close(1); dup(p[1])

close unused pipe ends

exec A

Fork child B:

redirect stdin:

close(0); dup(p[0])

close unused pipe ends

exec B

Parent closes both ends of pipe

Parent waits for both children

Traps checklist

Parent must close pipe ends or B may wait forever.

Each child must close the pipe ends it doesn’t use.

9) xargs pattern (the “stdin → argv → exec” machine)
Goal

Read text from stdin and use it as arguments to run a command.

Base idea

Pipes send data, but programs often need argv.

xargs converts input data into argv.

Flow (line-based xargs)

Start with base command from argv:

e.g. for xargs echo, base command is echo

Loop:

read one line from stdin

strip newline

build exec_argv[]:

exec_argv[0] = basecmd

optionally include fixed args (like grep foo)

append tokens from the input line (or the whole line, depending spec)

terminate with 0

fork()

child exec(basecmd, exec_argv)

parent wait()

repeat until EOF

Traps checklist

You must decide whether input line is:

one argument (entire line)

or multiple arguments (split by spaces)
based on question spec.

Don’t forget wait() or you spawn many children.

Don’t mix up xargs’s own argv vs the argv you pass to exec.

10) “find” pattern (recursive directory walk)
Goal

Search directories recursively and print matching paths.

Flow

open(path)

fstat(fd) to know if it’s file or directory

If file:

compare filename (basename) to target

if match: print full path

If directory:

loop reading struct dirent

skip "." and ".." always

build newpath = path + "/" + de.name

recurse on newpath

Close fd

Traps checklist

Always skip "." and ".." or you infinite loop.

Ensure path buffer length doesn’t overflow.

Directory entries include unused ones (inum==0) → skip.

11) “primes” pattern (the sieve with pipe+fork chain)
Goal

Create a pipeline of filters:

first process prints first prime, filters out multiples, sends rest to next

repeat recursively

Flow

One process reads first number from its input pipe:

if none → exit

That number is prime → print it

Create a new pipe for the next stage

Fork:

Child becomes next stage (reads from new pipe)

Parent filters:

read each number from input

if not divisible by prime, write to new pipe

Close write end to signal EOF

Wait for child

Exit

Traps checklist

If you don’t close the write end, next stage blocks forever.

Each stage must only pass non-multiples.

12) The “blocking / deadlock” debug checklist

Whenever something hangs, check in this order:

Both sides reading first?

If yes → deadlock.

Did every process close unused pipe ends?

If any unused write end is still open → reader might never see EOF.

Did the writer close its write end when done?

Otherwise reader waiting for more.

Did you redirect correctly before exec?

close(0)/close(1) done?

dup landed on correct fd?

Are you reading the correct pipe end?

p[0] read, p[1] write only.
